import "defs, lexer"
import "types"
Tokens = defs.Tokens
Nodes = defs.Nodes
throw = lexer.throw

fn Parser() {
  tokens = []

  fn _pop() {
    __inline("nonlocal tokens")
    return tokens.pop(0)
  }
  fn _expect(tok, err) {
    __inline("nonlocal tokens")
    prev = _pop()
    if (__inline("not prev") | prev[1] != tok) { throw("parser: {}, got {}".format(err, str(tok[0]) )) }
    return prev
  }

  fn parse(text) {
    __inline("nonlocal tokens")
    tokens = lexer.tokenize(text)
    prog = Nodes["Main"]([])
    for (_=0; tokens[0][1] != Tokens["EOF"]; _=0) { prog["body"].append(_stmt()) }
    return prog
  }

  fn _stmt() {
    if (tokens[0][1] == Tokens["Import"]) { return _stmt_import() }
    else if (tokens[0][1] == Tokens["Fn"] | tokens[0][1] == Tokens["Async"]) { return _stmt_fn() }
    else if (tokens[0][1] == Tokens["Ret"]) { return _stmt_ret() }
    else if (tokens[0][1] == Tokens["If"]) { return _stmt_if() }
    else if (tokens[0][1] == Tokens["For"]) { return _stmt_for() }
    else if (tokens[0][1] == Tokens["While"]) { return _stmt_while() }
    else if (tokens[0][1] == Tokens["Class"]) { return _stmt_class() }
    else { return _expr() }
  }


  // expressions
  fn _expr() { return _expr_set() }
  fn _expr_set() {
    if (tokens[0][1] == Tokens["Bigger"]  // >
      & tokens[1][1] == Tokens["POpen"])  // (
      { return _expr_lambda() }
    
    left = _expr_obj()
    if (tokens[0][1] == Tokens["Equals"]) {
      _pop()
      return Nodes["Assign"](left, _expr_set())
    }
    return left
  }
  fn _expr_lambda() { // >(args) {block} 
    _pop()
    params = []

    args = _args()
    for (i=0; i<len(args); i=i+1) {
      if (args[i]["t"] != "Word") {throw("parser: expected fn params to be Word")}
      params.append(args[i]["val"])
    }

    return Nodes["Lambda"](params, _block())
  }

  fn _expr_obj() {
    if (tokens[0][1] != Tokens["BOpen"]) { return _expr_arr() }
    props = []
    _pop()

    for (_=0; tokens[0][1] != Tokens["EOF"] & tokens[0][1] != Tokens["BClose"]; _=0) {
      if (tokens[0][1] == Tokens["Str"] | tokens[0][1] == Tokens["Int"]) {
        key = (_pop())[0]
      } else { key = (_expect(Tokens["Word"], "expected Word"))[0] }

      if (tokens[0][1] == Tokens["Comma"]) {
        _pop()
        props.append(Nodes["Prop"](key, None))
      } else if (tokens[0][1] == Tokens["BClose"]) {
        props.append(Nodes["Prop"](key, None))
      } else {
        _expect(Tokens["Colon"], "expected : following key")
        props.append(Nodes["Prop"](key, _expr()))

        if (tokens[0][1] != Tokens["BClose"]) { _expect(Tokens["Comma"], "expected , or } following prop") }
      }
    }

    _expect(Tokens["BClose"], "expected } after object")
    return Nodes["Object"](props)
  }

  fn _expr_arr() {
    if (tokens[0][1] != Tokens["SOpen"]) { return _expr_logic() }
    props = []
    _pop()
    for (_=0; tokens[0][1] != Tokens["EOF"] & tokens[0][1] != Tokens["SClose"]; _=0) {
      props.append(_expr())
      if (tokens[0][1] == Tokens["Comma"]) { _pop() }
    }

    _expect(Tokens["SClose"], "expected ] after array")
    return Nodes["Array"](props)
  }


  fn _expr_logic() {
    left = _expr_math()
    if ((["&", "|"]).__contains__(tokens[0][0])) {
      op = (_pop())[0]
      left = Nodes["BinOp"](left, _expr_math(), op)
    }
    return left
  }
  fn _expr_math() {
    left = _expr_call()
    for (_=0; (["+", "-", "*", "/", "%", "<", ">", "==", "!="]).__contains__(tokens[0][0]); _=0) {
      op = (_pop())[0]
      left = Nodes["BinOp"](left, _expr_call(), op)
    }
    return left
  }


  fn _expr_call() {
    fn _call(caller) {
      e = Nodes["Fcall"](caller, _args())
      while (tokens[0][1] == Tokens["POpen"]) { e = _call(e) }
      return e
    }
    left = _expr_member()
    if (tokens[0][1] == Tokens["POpen"]) { return _call(left) }
    return left
  }

  fn _expr_member() {
    left = _expr_final()
    for (_=0; tokens[0][1] == Tokens["Dot"] | tokens[0][1] == Tokens["SOpen"]; _=0) {
      op = _pop()
      if (op[1] == Tokens["Dot"]) {
        computed = False  prop = _expr_final()
        if (prop["t"] != "Word") { throw("parser: expected dot op to be followed by Word") }
      } else {
        computed = True   prop = _expr()
        _expect(Tokens["SClose"], "expected ]")
      }

      left = Nodes["Member"](left, prop, computed)
    }
    return left
  }


  fn _expr_final() {
    if (tokens[0][1] == Tokens["Word"]) { return Nodes["Word"]( (_pop())[0] ) }
    else if (tokens[0][1] == Tokens["Int"]) { return Nodes["Int"](float( (_pop())[0] )) }
    else if (tokens[0][1] == Tokens["Str"]) { return Nodes["Str"]( (_pop())[0] ) }
    else if (tokens[0][1] == Tokens["POpen"]) { 
      _pop()
      val = _expr()
      _expect(Tokens["PClose"], "expected )")
      return val
    } else { 
      throw("parser: unexpected token '{}'".format(tokens[0][0]))
    }
  }


  // statements
  fn _stmt_import() {
    _pop()
    // TODO:
    // val = this._expr();
    // if (val.t !== "Member" || val.t !== "Word") {}
    val = (_expect(Tokens["Str"], "expected str after import"))[0]
    return Nodes["ImportStmt"](val)
  }
  fn _stmt_fn() {
    isAsync = False
    if ((_pop())[1] == Tokens["Async"]) { isAsync = True  _pop() }

    name = (_expect(Tokens["Word"], "expected name after fn"))[0]
    params = []

    args = _args()
    for (i=0; i<len(args); i=i+1) {
      if (args[i]["t"] != "Word") { throw("parser: expected fn params to be Word") }
      params.append(args[i]["val"])
    }

    return Nodes["FnStmt"](name, params, _block(), isAsync)
  }
  fn _stmt_ret() { 
    _pop()
    return Nodes["RetStmt"](_expr())
  }

  fn _stmt_if() { 
    _pop() 
    _expect(Tokens["POpen"], "expected ( after if")
    cond = _expr()
    _expect(Tokens["PClose"], "expected ) after if")
    body = _block()

    alt = []
    if (tokens[0][1] == Tokens["Else"]) {
      _pop()
      if (tokens[0][1] == Tokens["If"]) { alt = [_stmt_if()] }
                                  else  { alt = _block() }
    }
    return Nodes["IfStmt"](cond, body, alt)
  }

  fn _stmt_for() {
    _pop()
    _expect(Tokens["POpen"], "expected ( after for")
    init = _expr()
    _expect(Tokens["Semi"], "expected ; following init")
    cond = _expr()
    _expect(Tokens["Semi"], "expected ; following condition")
    after = _expr()
    _expect(Tokens["PClose"], "expected ) after for")

    return Nodes["ForStmt"](init, cond, after, _block())
  }
  fn _stmt_while() {
    _pop()
    _expect(Tokens["POpen"], "expected ( after while")
    cond = _expr()
    _expect(Tokens["PClose"], "expected ) after while")

    return Nodes["WhileStmt"](cond, _block())
  }

  fn _stmt_class() {
    _pop()
    name = (_expect(Tokens["Word"], "expected Word after class"))[0]
    inherits = []

    args = _args()
    for (i=0; i<len(args); i=i+1) {
      if (args[i]["t"] != "Word") {throw("parser: expected class inherits to be Word")}
      inherits.append(args[i]["val"])
    }

    return Nodes["ClassStmt"](name, inherits, _block())
  }


  // reusable stuff
  fn __arglist() {
    fn parse() {
      left = _expr()
      if (tokens[0][1] == Tokens["Equals"]) {
        _pop()
        return Nodes["Assign"](left, parse())
      }
      return left
    }

    args = [parse()]
    for (_=0; tokens[0][1] == Tokens["Comma"] & _pop(); _=0) { args.append(parse()) }
    return args
  }

  fn _args() {
    _expect(Tokens["POpen"], "expected ( in args")
    args = []
    if (tokens[0][1] != Tokens["PClose"]) { args = __arglist() }
    _expect(Tokens["PClose"], "expected ) in args")
    return args
  }

  fn _block() {
    _expect(Tokens["BOpen"], "expected { in block")
    body = []
    for (_=0; tokens[0][1] != Tokens["EOF"] & tokens[0][1] != Tokens["BClose"]; _=0) {
      body.append(_stmt())
    }

    _expect(Tokens["BClose"], "expected } in block")
    return body
  }

  exports = {parse}
  return types.SimpleNamespace(__inline("**exports"))
}